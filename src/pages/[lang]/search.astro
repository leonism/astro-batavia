---
import Layout from '@/layouts/Layout.astro';
import SearchInputForm from '@/components/search/SearchInputForm.astro';
import SearchFilters from '@/components/search/SearchFilters.astro';
import SearchResults from '@/components/search/SearchResults.astro';
import { getCollection } from 'astro:content';
import { useTranslations, isValidLanguage } from '@/i18n/utils';

export async function getStaticPaths() {
  return [
    { params: { lang: "en" } },
    { params: { lang: "es" } },
    { params: { lang: "ja" } }
  ];
}

const { lang } = Astro.params;

// Validate language
if (!lang || !isValidLanguage(lang)) {
  return Astro.redirect("/404");
}

const t = useTranslations(lang);

// Fetch all posts to get unique tags for filtering
const allPosts = await getCollection('blog', ({ data }) => !data.draft);
const allTags = [...new Set(allPosts.flatMap(post => post.data.tags || []))].sort();

// Initial posts for display (empty, will be populated by client-side JS)
const initialPosts = [];
---

<Layout
  title={t('search.pageTitle')}
  description={t('search.pageDescription')}
  lang={lang}
>
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <header class="text-center mb-12">
      <h1 class="text-4xl sm:text-5xl font-bold text-gray-900 dark:text-gray-100 mb-4">
        {t('search.pageTitle')}
      </h1>
      <p class="text-xl text-gray-600 dark:text-gray-300 max-w-3xl mx-auto mb-4">
        {t('search.pageDescription')}
      </p>
      
      <!-- Keyboard Navigation Instructions -->
      <details class="max-w-2xl mx-auto mb-6">
        <summary class="cursor-pointer text-sm text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 focus:outline-none focus:ring-2 focus:ring-primary-500 rounded px-2 py-1">
          Keyboard Navigation Help
        </summary>
        <div class="mt-3 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg text-sm text-gray-600 dark:text-gray-400 text-left">
          <ul class="space-y-2">
            <li><kbd class="px-2 py-1 bg-gray-200 dark:bg-gray-700 rounded text-xs">Ctrl/⌘ + K</kbd> Focus search input</li>
            <li><kbd class="px-2 py-1 bg-gray-200 dark:bg-gray-700 rounded text-xs">↑ ↓</kbd> Navigate through suggestions and results</li>
            <li><kbd class="px-2 py-1 bg-gray-200 dark:bg-gray-700 rounded text-xs">Enter</kbd> Select suggestion or open result</li>
            <li><kbd class="px-2 py-1 bg-gray-200 dark:bg-gray-700 rounded text-xs">Escape</kbd> Clear selections or close suggestions</li>
            <li><kbd class="px-2 py-1 bg-gray-200 dark:bg-gray-700 rounded text-xs">Tab</kbd> Navigate between interface elements</li>
            <li><kbd class="px-2 py-1 bg-gray-200 dark:bg-gray-700 rounded text-xs">Ctrl/⌘ + Home/End</kbd> Jump to first/last result</li>
          </ul>
        </div>
      </details>
    </header>

    <SearchInputForm placeholder={t('search.inputPlaceholder')} />

    <SearchFilters tags={allTags} />

    <SearchResults
      posts={initialPosts}
      lang={lang}
      noResultsText={t('search.noResults')}
      initialStatusText={t('search.initialStatus')}
    />
  </div>
</Layout>

<script type="module">
  import EnhancedSearchClient from '/src/features/search/EnhancedSearchClient.js';

  document.addEventListener('astro:page-load', async () => {
    console.log('Enhanced search page loading...');
    
    // Initialize enhanced search client
    const searchClient = new EnhancedSearchClient({
      searchInputId: 'main-search-input',
      resultsContainerId: 'search-results',
      statusElementId: 'search-status',
      noResultsElementId: 'no-results',
      debounceMs: 150,
      minQueryLength: 1,
      maxSuggestions: 8,
      enableVoiceSearch: true,
      enableKeyboardNavigation: true,
      enableAnalytics: true
    });

    try {
      console.log('Fetching search index...');
      const response = await fetch('/api/search-index');
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const documents = await response.json();
      console.log(`Fetched ${documents.length} documents for indexing`);
      
      await searchClient.initialize(documents);
      console.log('Enhanced search client initialized successfully');
      
    } catch (error) {
      console.error('Failed to initialize search:', error);
      return;
    }

    // Handle URL parameters for initial search
    const urlParams = new URLSearchParams(window.location.search);
    const initialQuery = urlParams.get('q');
    const initialTag = urlParams.get('tag');

    if (initialQuery) {
      const searchInput = document.getElementById('main-search-input');
      if (searchInput) {
        searchInput.value = initialQuery;
        const results = await searchClient.search(initialQuery, {
          tags: initialTag ? [initialTag] : []
        });
        searchClient.displayResults(results);
      }
    }

    // Handle tag filtering
    const tagFilterButtons = document.querySelectorAll('.tag-filter');
    let currentFilters = { tags: initialTag ? [initialTag] : [] };
    let currentSort = { sortBy: 'hybrid', sortOrder: 'desc' };

    // Update active tag filter
    if (initialTag) {
      const targetButton = document.querySelector(`.tag-filter[data-tag="${initialTag}"]`);
      if (targetButton) {
        tagFilterButtons.forEach(btn => btn.classList.remove('active'));
        targetButton.classList.add('active');
      }
    }

    tagFilterButtons.forEach(button => {
      button.addEventListener('click', async () => {
        tagFilterButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        
        const tag = button.dataset.tag;
        currentFilters.tags = tag === 'all' ? [] : [tag];
        
        const searchInput = document.getElementById('main-search-input');
        const query = searchInput ? searchInput.value : '';
        
        if (query) {
          const results = await searchClient.search(query, { 
            ...currentFilters, 
            ...currentSort 
          });
          searchClient.displayResults(results);
        }
      });
    });

    // Handle sort options
    const sortSelect = document.getElementById('sort-select');
    if (sortSelect) {
      // Add new sort options
      const existingOptions = sortSelect.innerHTML;
      sortSelect.innerHTML = `
        <option value="hybrid-desc">Best Match</option>
        <option value="relevance-desc">Most Relevant</option>
        <option value="semantic-desc">Semantic Match</option>
        <option value="date-desc">Newest First</option>
        <option value="date-asc">Oldest First</option>
        <option value="title-asc">Title A-Z</option>
        <option value="title-desc">Title Z-A</option>
      `;
      sortSelect.value = 'hybrid-desc';
      
      sortSelect.addEventListener('change', async () => {
        const [sortBy, sortOrder] = sortSelect.value.split('-');
        currentSort = { sortBy, sortOrder };
        
        const searchInput = document.getElementById('main-search-input');
        const query = searchInput ? searchInput.value : '';
        
        if (query) {
          const results = await searchClient.search(query, {
            ...currentFilters,
            ...currentSort
          });
          searchClient.displayResults(results);
        }
      });
    }

    // Performance optimization - cleanup on page unload
    window.addEventListener('beforeunload', () => {
      searchClient.optimizePerformance();
    });

    // Expose search insights to console for debugging
    window.searchInsights = () => {
      console.log('Search Insights:', searchClient.getInsights());
    };

    console.log('Enhanced search page loaded successfully');
    console.log('Try Ctrl/Cmd + K to focus search, or type "searchInsights()" in console for analytics');
  });
</script>
